// Frontend API Client for SAT RSPO PADI Supabase Backend
// This file provides React hooks and utilities for interacting with the backend API

import { createClient } from '@supabase/supabase-js'\nimport { useState, useEffect, useCallback, createContext, useContext } from 'react'\nimport type { \n  Database, \n  AuthUser, \n  UserProfile, \n  Assessment, \n  RegisterRequest,\n  LoginRequest,\n  AuthResponse,\n  ProfileResponse,\n  AssessmentResponse,\n  CreateAssessmentRequest,\n  UpdateAssessmentRequest,\n  UseAuthReturn,\n  UseAssessmentReturn\n} from '../api/types/database'\n\n// Supabase client configuration\nconst supabaseUrl = process.env.REACT_APP_SUPABASE_URL || process.env.NEXT_PUBLIC_SUPABASE_URL\nconst supabaseAnonKey = process.env.REACT_APP_SUPABASE_ANON_KEY || process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY\n\nif (!supabaseUrl || !supabaseAnonKey) {\n  throw new Error('Missing Supabase environment variables')\n}\n\nexport const supabase = createClient<Database>(supabaseUrl, supabaseAnonKey)\n\n// API Base URL\nconst API_BASE_URL = process.env.REACT_APP_API_URL || process.env.NEXT_PUBLIC_API_URL || '/api'\n\n// HTTP Client with auth headers\nclass ApiClient {\n  private baseURL: string\n  private token: string | null = null\n\n  constructor(baseURL: string) {\n    this.baseURL = baseURL\n  }\n\n  setToken(token: string | null) {\n    this.token = token\n  }\n\n  private async request<T>(endpoint: string, options: RequestInit = {}): Promise<T> {\n    const url = `${this.baseURL}${endpoint}`\n    \n    const headers: Record<string, string> = {\n      'Content-Type': 'application/json',\n      ...options.headers as Record<string, string>\n    }\n\n    if (this.token) {\n      headers.Authorization = `Bearer ${this.token}`\n    }\n\n    const response = await fetch(url, {\n      ...options,\n      headers\n    })\n\n    if (!response.ok) {\n      const errorData = await response.json().catch(() => ({ error: 'Network error' }))\n      throw new Error(errorData.error || `HTTP ${response.status}`)\n    }\n\n    return response.json()\n  }\n\n  async get<T>(endpoint: string): Promise<T> {\n    return this.request<T>(endpoint, { method: 'GET' })\n  }\n\n  async post<T>(endpoint: string, data?: any): Promise<T> {\n    return this.request<T>(endpoint, {\n      method: 'POST',\n      body: data ? JSON.stringify(data) : undefined\n    })\n  }\n\n  async put<T>(endpoint: string, data?: any): Promise<T> {\n    return this.request<T>(endpoint, {\n      method: 'PUT',\n      body: data ? JSON.stringify(data) : undefined\n    })\n  }\n\n  async delete<T>(endpoint: string): Promise<T> {\n    return this.request<T>(endpoint, { method: 'DELETE' })\n  }\n}\n\nconst apiClient = new ApiClient(API_BASE_URL)\n\n// Auth Context\ninterface AuthContextType {\n  user: AuthUser | null\n  profile: UserProfile | null\n  loading: boolean\n  signIn: (email: string, password: string) => Promise<AuthResponse>\n  signUp: (data: RegisterRequest) => Promise<AuthResponse>\n  signOut: () => Promise<void>\n  updateProfile: (data: Partial<UserProfile>) => Promise<ProfileResponse>\n}\n\nconst AuthContext = createContext<AuthContextType | null>(null)\n\n// Auth Provider Component\nexport const AuthProvider: React.FC<{ children: React.ReactNode }> = ({ children }) => {\n  const [user, setUser] = useState<AuthUser | null>(null)\n  const [profile, setProfile] = useState<UserProfile | null>(null)\n  const [loading, setLoading] = useState(true)\n\n  useEffect(() => {\n    // Get initial session\n    const getSession = async () => {\n      const { data: { session } } = await supabase.auth.getSession()\n      if (session?.user) {\n        setUser(session.user as AuthUser)\n        apiClient.setToken(session.access_token)\n        await fetchProfile(session.user.id)\n      }\n      setLoading(false)\n    }\n\n    getSession()\n\n    // Listen for auth changes\n    const { data: { subscription } } = supabase.auth.onAuthStateChange(\n      async (event, session) => {\n        if (session?.user) {\n          setUser(session.user as AuthUser)\n          apiClient.setToken(session.access_token)\n          await fetchProfile(session.user.id)\n        } else {\n          setUser(null)\n          setProfile(null)\n          apiClient.setToken(null)\n        }\n        setLoading(false)\n      }\n    )\n\n    return () => subscription.unsubscribe()\n  }, [])\n\n  const fetchProfile = async (userId: string) => {\n    try {\n      const response = await apiClient.get<ProfileResponse>('/profile')\n      if (response.success && response.data) {\n        setProfile(response.data)\n      }\n    } catch (error) {\n      console.error('Error fetching profile:', error)\n    }\n  }\n\n  const signIn = async (email: string, password: string): Promise<AuthResponse> => {\n    try {\n      const response = await apiClient.post<AuthResponse>('/login', { email, password })\n      return response\n    } catch (error: any) {\n      throw new Error(error.message || 'Login failed')\n    }\n  }\n\n  const signUp = async (data: RegisterRequest): Promise<AuthResponse> => {\n    try {\n      const response = await apiClient.post<AuthResponse>('/register', data)\n      return response\n    } catch (error: any) {\n      throw new Error(error.message || 'Registration failed')\n    }\n  }\n\n  const signOut = async (): Promise<void> => {\n    try {\n      await apiClient.post('/logout')\n      await supabase.auth.signOut()\n    } catch (error) {\n      console.error('Logout error:', error)\n    }\n  }\n\n  const updateProfile = async (data: Partial<UserProfile>): Promise<ProfileResponse> => {\n    try {\n      const response = await apiClient.put<ProfileResponse>('/profile', data)\n      if (response.success && response.data) {\n        setProfile(response.data)\n      }\n      return response\n    } catch (error: any) {\n      throw new Error(error.message || 'Profile update failed')\n    }\n  }\n\n  return (\n    <AuthContext.Provider value={{\n      user,\n      profile,\n      loading,\n      signIn,\n      signUp,\n      signOut,\n      updateProfile\n    }}>\n      {children}\n    </AuthContext.Provider>\n  )\n}\n\n// useAuth Hook\nexport const useAuth = (): UseAuthReturn => {\n  const context = useContext(AuthContext)\n  if (!context) {\n    throw new Error('useAuth must be used within an AuthProvider')\n  }\n\n  return {\n    user: context.user,\n    profile: context.profile,\n    loading: context.loading,\n    error: null, // You can implement error state if needed\n    signIn: context.signIn,\n    signUp: context.signUp,\n    signOut: context.signOut,\n    updateProfile: context.updateProfile,\n    refreshSession: async () => {\n      await supabase.auth.refreshSession()\n    }\n  }\n}\n\n// useAssessment Hook\nexport const useAssessment = (): UseAssessmentReturn => {\n  const [assessments, setAssessments] = useState<Assessment[]>([])\n  const [currentAssessment, setCurrentAssessment] = useState<Assessment | null>(null)\n  const [loading, setLoading] = useState(false)\n  const [error, setError] = useState<string | null>(null)\n\n  const createAssessment = useCallback(async (data: CreateAssessmentRequest): Promise<AssessmentResponse> => {\n    setLoading(true)\n    setError(null)\n    try {\n      const response = await apiClient.post<AssessmentResponse>('/save-assessment', data)\n      if (response.success && response.data) {\n        setAssessments(prev => [response.data!, ...prev])\n        setCurrentAssessment(response.data)\n      }\n      return response\n    } catch (err: any) {\n      setError(err.message)\n      throw err\n    } finally {\n      setLoading(false)\n    }\n  }, [])\n\n  const updateAssessment = useCallback(async (id: string, data: UpdateAssessmentRequest): Promise<AssessmentResponse> => {\n    setLoading(true)\n    setError(null)\n    try {\n      const response = await apiClient.put<AssessmentResponse>(`/save-assessment?id=${id}`, data)\n      if (response.success && response.data) {\n        setAssessments(prev => prev.map(a => a.id === id ? response.data! : a))\n        if (currentAssessment?.id === id) {\n          setCurrentAssessment(response.data)\n        }\n      }\n      return response\n    } catch (err: any) {\n      setError(err.message)\n      throw err\n    } finally {\n      setLoading(false)\n    }\n  }, [currentAssessment])\n\n  const getAssessment = useCallback(async (id: string): Promise<AssessmentResponse> => {\n    setLoading(true)\n    setError(null)\n    try {\n      const response = await apiClient.get<AssessmentResponse>(`/save-assessment?id=${id}`)\n      if (response.success && response.data) {\n        setCurrentAssessment(response.data)\n      }\n      return response\n    } catch (err: any) {\n      setError(err.message)\n      throw err\n    } finally {\n      setLoading(false)\n    }\n  }, [])\n\n  const getAssessments = useCallback(async (params?: { stage?: string; limit?: number; offset?: number }) => {\n    setLoading(true)\n    setError(null)\n    try {\n      const queryParams = new URLSearchParams()\n      if (params?.stage) queryParams.set('stage', params.stage)\n      if (params?.limit) queryParams.set('limit', params.limit.toString())\n      if (params?.offset) queryParams.set('offset', params.offset.toString())\n      \n      const url = `/save-assessment${queryParams.toString() ? '?' + queryParams.toString() : ''}`\n      const response = await apiClient.get<{ success: boolean; data: Assessment[] }>(url)\n      \n      if (response.success && response.data) {\n        setAssessments(response.data)\n      }\n      return response\n    } catch (err: any) {\n      setError(err.message)\n      throw err\n    } finally {\n      setLoading(false)\n    }\n  }, [])\n\n  const deleteAssessment = useCallback(async (id: string) => {\n    setLoading(true)\n    setError(null)\n    try {\n      const response = await apiClient.delete(`/save-assessment?id=${id}`)\n      setAssessments(prev => prev.filter(a => a.id !== id))\n      if (currentAssessment?.id === id) {\n        setCurrentAssessment(null)\n      }\n      return response\n    } catch (err: any) {\n      setError(err.message)\n      throw err\n    } finally {\n      setLoading(false)\n    }\n  }, [currentAssessment])\n\n  return {\n    assessments,\n    currentAssessment,\n    loading,\n    error,\n    createAssessment,\n    updateAssessment,\n    getAssessment,\n    getAssessments,\n    deleteAssessment\n  }\n}\n\n// Helper function to format API errors\nexport const formatApiError = (error: any): string => {\n  if (error.response?.data?.error) {\n    return error.response.data.error\n  }\n  if (error.message) {\n    return error.message\n  }\n  return 'An unexpected error occurred'\n}\n\n// Export the API client for direct use if needed\nexport { apiClient }